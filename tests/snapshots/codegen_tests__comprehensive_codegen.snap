---
source: tests/codegen_tests.rs
expression: rust_code
---
mod liva_rt {
    use std::future::Future;
    use tokio::task::JoinHandle;
    
    /// Runtime error type for fallible operations
    #[derive(Debug, Clone)]
    pub struct Error {
        pub message: String,
    }
    
    impl Error {
        pub fn from<S: Into<String>>(message: S) -> Self {
            Error {
                message: message.into(),
            }
        }
    }
    
    impl std::fmt::Display for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.message)
        }
    }
    
    impl std::error::Error for Error {}
    
    /// Spawn an async task
    pub fn spawn_async<F, T>(future: F) -> JoinHandle<T>
    where
        F: Future<Output = T> + Send + 'static,
        T: Send + 'static,
    {
        tokio::spawn(future)
    }
    /// Fire and forget async task
    pub fn fire_async<F>(future: F)
    where
        F: Future<Output = ()> + Send + 'static,
    {
        tokio::spawn(future);
    }
    /// Spawn a parallel task
    pub fn spawn_parallel<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static,
    {
        // For simplicity, just execute synchronously and wrap in JoinHandle
        // In a real implementation, this would use rayon or std::thread
        let result = f();
        tokio::spawn(async move { result })
    }
    /// Fire and forget parallel task
    pub fn fire_parallel<F>(f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        // For simplicity, just spawn a thread
        std::thread::spawn(f);
    }
}

fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn multiply(x: i32, y: i32) -> i32 {
    x * y
}

fn power(base: i32, exp: i32) -> i32 {
    base * exp
}

fn complex_calculation(n: i32) -> f64 {
    let mut doubled = n * 2;
    let mut squared = doubled * doubled;
    return squared;
}

fn main() {
    let mut sum = add(10, 5);
    let mut product = multiply(3, 4);
    let mut powered = power(2, 3);
    let mut complex = complex_calculation(5);
    println!("{}", format!("{}{}", "Sum: ", sum));
    println!("{}", format!("{}{}", "Product: ", product));
    println!("{}", format!("{}{}", "Power: ", powered));
    println!("{}", format!("{}{}", "Complex: ", complex));
}
