---
source: tests/codegen_ir_tests.rs
expression: rust_code
---
mod liva_rt {
    use std::future::Future;
    use tokio::task::JoinHandle;
    
    /// Runtime error type for fallible operations
    #[derive(Debug, Clone)]
    pub struct Error {
        pub message: String,
    }
    
    impl Error {
        pub fn from<S: Into<String>>(message: S) -> Self {
            Error {
                message: message.into(),
            }
        }
    }
    
    impl std::fmt::Display for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.message)
        }
    }
    
    impl std::error::Error for Error {}
    
    /// Spawn an async task
    pub fn spawn_async<F, T>(future: F) -> JoinHandle<T>
    where
        F: Future<Output = T> + Send + 'static,
        T: Send + 'static,
    {
        tokio::spawn(future)
    }
    /// Fire and forget async task
    pub fn fire_async<F>(future: F)
    where
        F: Future<Output = ()> + Send + 'static,
    {
        tokio::spawn(future);
    }
    /// Spawn a parallel task
    pub fn spawn_parallel<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static,
    {
        // For simplicity, just execute synchronously and wrap in JoinHandle
        // In a real implementation, this would use rayon or std::thread
        let result = f();
        tokio::spawn(async move { result })
    }
    /// Fire and forget parallel task
    pub fn fire_parallel<F>(f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        // For simplicity, just spawn a thread
        std::thread::spawn(f);
    }
    
    /// String multiplication helper
    /// Supports both String*int and int*String patterns
    pub fn string_mul<L: StringOrInt, R: StringOrInt>(left: L, right: R) -> String {
        match (left.as_string_or_int(), right.as_string_or_int()) {
            (StringOrIntValue::String(s), StringOrIntValue::Int(n)) => {
                if n <= 0 { String::new() } else { s.repeat(n as usize) }
            }
            (StringOrIntValue::Int(n), StringOrIntValue::String(s)) => {
                if n <= 0 { String::new() } else { s.repeat(n as usize) }
            }
            (StringOrIntValue::Int(a), StringOrIntValue::Int(b)) => {
                (a * b).to_string()
            }
            (StringOrIntValue::String(_), StringOrIntValue::String(_)) => {
                panic!("Cannot multiply two strings")
            }
        }
    }
    
    pub enum StringOrIntValue {
        String(String),
        Int(i64),
    }
    
    pub trait StringOrInt {
        fn as_string_or_int(self) -> StringOrIntValue;
    }
    
    impl StringOrInt for String {
        fn as_string_or_int(self) -> StringOrIntValue { StringOrIntValue::String(self) }
    }
    impl StringOrInt for &str {
        fn as_string_or_int(self) -> StringOrIntValue { StringOrIntValue::String(self.to_string()) }
    }
    impl StringOrInt for i32 {
        fn as_string_or_int(self) -> StringOrIntValue { StringOrIntValue::Int(self as i64) }
    }
    impl StringOrInt for i64 {
        fn as_string_or_int(self) -> StringOrIntValue { StringOrIntValue::Int(self) }
    }
    impl StringOrInt for f64 {
        fn as_string_or_int(self) -> StringOrIntValue { StringOrIntValue::Int(self as i64) }
    }
    impl StringOrInt for usize {
        fn as_string_or_int(self) -> StringOrIntValue { StringOrIntValue::Int(self as i64) }
    }
}

fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn main() {
    let mut result = add(2, 3);
    println!("{}", result);
}
