---
source: tests/codegen_ir_tests.rs
expression: rust_code
---
use tokio;

mod liva_rt {
    use std::future::Future;
    use tokio::task::JoinHandle;
    
    /// Runtime error type for fallible operations
    #[derive(Debug, Clone)]
    pub struct Error {
        pub message: String,
    }
    
    impl Error {
        pub fn from<S: Into<String>>(message: S) -> Self {
            Error {
                message: message.into(),
            }
        }
    }
    
    impl std::fmt::Display for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.message)
        }
    }
    
    impl std::error::Error for Error {}
    
    /// Spawn an async task
    pub fn spawn_async<F, T>(future: F) -> JoinHandle<T>
    where
        F: Future<Output = T> + Send + 'static,
        T: Send + 'static,
    {
        tokio::spawn(future)
    }
    /// Fire and forget async task
    pub fn fire_async<F>(future: F)
    where
        F: Future<Output = ()> + Send + 'static,
    {
        tokio::spawn(future);
    }
    /// Spawn a parallel task
    pub fn spawn_parallel<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static,
    {
        // For simplicity, just execute synchronously and wrap in JoinHandle
        // In a real implementation, this would use rayon or std::thread
        let result = f();
        tokio::spawn(async move { result })
    }
    /// Fire and forget parallel task
    pub fn fire_parallel<F>(f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        // For simplicity, just spawn a thread
        std::thread::spawn(f);
    }
}

fn heavy() -> f64 {
    return liva_rt::spawn_parallel(move || compute());
}

fn main() {
    let value_task = liva_rt::spawn_parallel(move || heavy());
    liva_rt::fire_parallel(move || { heavy(); });
    let mut value = value_task.await.unwrap();
    println!("{}", value);
}
