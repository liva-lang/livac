// Test 2: Generic Pair<K,V> with methods
// Testing methods on generic classes

Pair<K, V> {
    key: K
    val: V
    
    constructor(key: K, val: V) {
        this.key = key
        this.val = val
    }
    
    // Create a reversed pair (V, K)
    // Note: Can't return Pair<V,K> because that's a different type
    // So we'll test direct field access instead
}

// Testing generic function that takes a pair
describePair(p: Pair<number, string>): string {
    return $"Pair({p.key}, {p.val})"
}

// Cache entry with generic value
CacheEntry<T> {
    key: string
    value: T
    hits: number
    
    constructor(key: string, value: T) {
        this.key = key
        this.value = value
        this.hits = 0
    }
    
    // Record a cache hit
    hit() {
        this.hits = this.hits + 1
    }
    
    // Set new value
    setValue(v: T) {
        this.value = v
    }
    
    // Get description
    describe(): string {
        return $"Cache[{this.key}] hits={this.hits}"
    }
}

// Key-Value store with arrays
KVStore<K, V> {
    keys: [K]
    values: [V]
    
    constructor() {
        this.keys = []
        this.values = []
    }
    
    // Get count
    count(): number {
        return this.keys.length
    }
    
    // Add entry (simplified - no push for now due to Bug #43)
    // We'll test after fixing the mut inference bug
}

main() {
    print("=== Pair<number, string> Test ===")
    let pair1 = Pair(1, "one")
    print($"Key: {pair1.key}, Value: {pair1.val}")
    print($"Describe: {describePair(pair1)}")
    
    print("\n=== Pair<string, number> Test ===")
    let pair2 = Pair("age", 25)
    print($"Key: {pair2.key}, Value: {pair2.val}")
    
    print("\n=== Pair<bool, float> Test ===")
    let pair3 = Pair(true, 3.14)
    print($"Key: {pair3.key}, Value: {pair3.val}")
    
    print("\n=== CacheEntry<number> Test ===")
    let cache1 = CacheEntry("count", 42)
    print(cache1.describe())
    cache1.hit()
    cache1.hit()
    cache1.hit()
    print(cache1.describe())
    print($"Cached value: {cache1.value}")
    
    print("\n=== CacheEntry<string> Test ===")
    let cache2 = CacheEntry("name", "Alice")
    cache2.hit()
    print(cache2.describe())
    print($"Cached value: {cache2.value}")
    
    print("\n=== CacheEntry with setValue ===")
    let cache3 = CacheEntry("status", "active")
    print($"Original: {cache3.value}")
    cache3.setValue("inactive")
    print($"Updated: {cache3.value}")
    
    print("\nâœ… Pair and CacheEntry tests complete!")
}
