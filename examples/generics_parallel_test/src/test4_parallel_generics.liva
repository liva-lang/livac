// Test 4: Combining generics with parallel operations
// Testing what works, documenting bugs

// Generic wrapper for computed results
Result<T> {
    value: T
    computed: bool
    
    constructor(value: T) {
        this.value = value
        this.computed = true
    }
    
    // Bug #54: describe() with {this.value} needs Display bound
    // Removed for now
}

// Generic stats (non-generic to avoid issues)
Stats {
    min: number
    max: number
    sum: number
    count: number
    
    constructor(min: number, max: number, sum: number, count: number) {
        this.min = min
        this.max = max
        this.sum = sum
        this.count = count
    }
    
    average(): number {
        return this.sum / this.count
    }
}

// Compute stats from array
computeStats(nums: [number]): Stats {
    let min = nums[0]
    let max = nums[0]
    let sum = 0
    
    for i in 0..nums.length {
        let n = nums[i]
        if n < min { min = n }
        if n > max { max = n }
        sum = sum + n
    }
    
    return Stats(min, max, sum, nums.length)
}

main() {
    print("=== Generic Result instances ===")
    // Bug #51: arrays of generics have field access issues
    // Test individual instances instead
    let r1 = Result(100)
    let r2 = Result(200)
    let r3 = Result(300)
    
    print($"r1: {r1.value}, computed: {r1.computed}")
    print($"r2: {r2.value}, computed: {r2.computed}")
    print($"r3: {r3.value}, computed: {r3.computed}")
    
    print("\n=== Parallel Map then Stats ===")
    let data = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
    
    // Parallel transform
    let doubled = data.par().map(x => x * 2)
    print($"Doubled data: {doubled}")
    
    // Compute stats on result
    let stats = computeStats(doubled)
    print($"Min: {stats.min}")
    print($"Max: {stats.max}")
    print($"Sum: {stats.sum}")
    print($"Count: {stats.count}")
    print($"Average: {stats.average()}")
    
    print("\n=== Large Parallel with Stats ===")
    let large: [number] = []
    for i in 1..101 {
        large.push(i)
    }
    
    let largeSquared = large.par().map(x => x * x)
    let largeStats = computeStats(largeSquared)
    
    print($"Squared stats for 1-100:")
    print($"  Min: {largeStats.min} (1^2)")
    print($"  Max: {largeStats.max} (100^2)")
    print($"  Sum: {largeStats.sum}")
    print($"  Average: {largeStats.average()}")
    
    print("\n=== Generic with different types ===")
    let strResult = Result("hello")
    let boolResult = Result(true)
    let floatResult = Result(3.14159)
    
    print($"String result: {strResult.value}")
    print($"Bool result: {boolResult.value}")
    print($"Float result: {floatResult.value}")
    
    print("\nâœ… Generics + Parallel tests complete!")
    print("\nNote: Bug #51 - arrays of generic instances have field access issues")
}