# üéØ Modos de Ejecuci√≥n en Liva

## Introducci√≥n

Liva ofrece **7 formas distintas** de ejecutar una funci√≥n, cada una dise√±ada para un caso de uso espec√≠fico. Este documento explica cu√°ndo y c√≥mo usar cada una.

## üìä Tabla Comparativa Completa

| Sintaxis | Retorna | Bloquea | Error Binding | Lazy Eval | Caso de Uso |
|----------|---------|---------|---------------|-----------|-------------|
| `f()` | Valor | S√≠ (inmediato) | ‚úÖ | No | Ejecuci√≥n s√≠ncrona normal |
| `async f()` | Valor | En primer uso | ‚úÖ | S√≠ | I/O async con lazy await |
| `par f()` | Valor | En primer uso | ‚úÖ | S√≠ | CPU paralelo con lazy join |
| `task async f()` | JoinHandle | No | ‚ùå | No | Control manual async |
| `task par f()` | JoinHandle | No | ‚ùå | No | Control manual parallel |
| `fire async f()` | Void | No | ‚ùå | N/A | Fire-and-forget async |
| `fire par f()` | Void | No | ‚ùå | N/A | Fire-and-forget parallel |

## 1. üîµ Ejecuci√≥n Normal (S√≠ncrona)

### Sintaxis
```liva
let result = functionName(args)
```

### Comportamiento
- Ejecuta la funci√≥n **inmediatamente**
- **Bloquea** hasta que la funci√≥n termine
- Retorna el valor directamente
- Error binding disponible

### Ejemplo B√°sico
```liva
divide(a: number, b: number): number {
    if b == 0 fail "Division by zero"
    return a / b
}

main() {
    let result = divide(10, 2)
    print($"Result: {result}")  // Output: 5
}
```

### Con Error Binding
```liva
main() {
    let result, err = divide(10, 0)
    if err != "" {
        print($"Error: {err}")  // Output: Division by zero
    } else {
        print($"Result: {result}")
    }
}
```

### C√≥digo Rust Generado
```rust
// Sin error binding
let result = divide(10, 2);

// Con error binding
let (result, err) = match divide(10, 0) { 
    Ok(v) => (v, "".to_string()), 
    Err(e) => (Default::default(), e.message) 
};
```

### ‚úÖ Cu√°ndo Usar
- Operaciones r√°pidas y s√≠ncronas
- Computaci√≥n local sin I/O
- Cuando el orden de ejecuci√≥n es importante
- Cuando necesitas el resultado inmediatamente

### ‚ùå Cu√°ndo NO Usar
- Operaciones de I/O lentas (usa `async`)
- Computaci√≥n intensiva de CPU (usa `par`)
- Cuando quieres hacer otras cosas mientras esperas

---

## 2. üü¢ Async (Lazy Await)

### Sintaxis
```liva
let value = async functionName(args)
```

### Comportamiento
- **NO bloquea** inmediatamente
- Retorna un valor "lazy"
- Se ejecuta en background
- **Bloquea autom√°ticamente** en primer uso del valor (Phase 2)
- Error binding disponible

### Ejemplo B√°sico
```liva
fetchUser(id: number): User {
    // Simula llamada HTTP
    return User("Alice", id)
}

main() {
    // NO bloquea aqu√≠ - lanza la operaci√≥n
    let user = async fetchUser(1)
    
    // Hacer otras cosas mientras fetch est√° en progreso
    doSomething()
    
    // Bloquea AQU√ç cuando accedes al valor (Phase 2)
    print($"User: {user.name}")  // Await impl√≠cito
}
```

### Con Error Binding (Phase 1 ‚úÖ)
```liva
getUser(id: number): User {
    if id == 0 fail "Invalid ID"
    return User("Test", id)
}

main() {
    let user, err = async getUser(0)
    
    if err != "" {
        print($"Error: {err}")
    } else {
        print($"User: {user.name}")
    }
}
```

### C√≥digo Rust Generado
```rust
// B√°sico (actualmente hace await inmediato, Phase 2 lo har√° lazy)
let mut user = liva_rt::spawn_async(async move { 
    fetch_user(1) 
}).await.unwrap();

// Con error binding
let (user, err) = match liva_rt::spawn_async(async move { 
    get_user(0) 
}).await.unwrap() { 
    Ok(v) => (v, "".to_string()), 
    Err(e) => (Default::default(), e.message) 
};
```

### ‚úÖ Cu√°ndo Usar
- Operaciones de I/O (HTTP, database, files)
- Llamadas a APIs externas
- Operaciones de red
- Cuando quieres hacer otras cosas mientras esperas

### ‚ùå Cu√°ndo NO Usar
- Computaci√≥n intensiva de CPU (usa `par`)
- Cuando necesitas control manual del timing (usa `task async`)
- Para operaciones que no te importa el resultado (usa `fire async`)

---

## 3. üü° Parallel (Lazy Join)

### Sintaxis
```liva
let result = par functionName(args)
```

### Comportamiento
- **NO bloquea** inmediatamente
- Ejecuta en thread/worker separado
- Retorna un valor "lazy"
- **Bloquea autom√°ticamente** en primer uso del valor (Phase 2)
- Error binding disponible

### Ejemplo B√°sico
```liva
heavyComputation(n: number): number {
    // Computaci√≥n intensiva
    let result = n * n * n
    return result
}

main() {
    // NO bloquea aqu√≠ - lanza el c√≥mputo
    let result = par heavyComputation(1000)
    
    // Hacer otras cosas mientras computa
    doOtherWork()
    
    // Bloquea AQU√ç cuando accedes al valor (Phase 2)
    print($"Result: {result}")  // Join impl√≠cito
}
```

### Con Error Binding (Phase 1 ‚úÖ)
```liva
compute(n: number): number {
    if n < 0 fail "Negative number"
    return n * n
}

main() {
    let result, err = par compute(-5)
    
    if err != "" {
        print($"Error: {err}")
    } else {
        print($"Result: {result}")
    }
}
```

### C√≥digo Rust Generado
```rust
// B√°sico (actualmente hace await/join inmediato)
let mut result = liva_rt::spawn_parallel(move || 
    heavy_computation(1000)
).await.unwrap();

// Con error binding
let (result, err) = match liva_rt::spawn_parallel(move || 
    compute(-5)
).await.unwrap() { 
    Ok(v) => (v, "".to_string()), 
    Err(e) => (Default::default(), e.message) 
};
```

### ‚úÖ Cu√°ndo Usar
- Computaci√≥n intensiva de CPU
- Procesamiento de im√°genes
- C√°lculos matem√°ticos complejos
- Cuando tienes m√∫ltiples cores disponibles

### ‚ùå Cu√°ndo NO Usar
- Operaciones de I/O (usa `async`)
- Cuando necesitas control manual (usa `task par`)
- Para operaciones que no te importa el resultado (usa `fire par`)

---

## 4. üî∑ Task Async (Control Manual)

### Sintaxis
```liva
let handle = task async functionName(args)
let result = await handle
```

### Comportamiento
- Retorna un **JoinHandle** (no el valor)
- **NO bloquea** autom√°ticamente
- Te da control manual de cu√°ndo hacer await
- NO tiene error binding autom√°tico
- √ötil para composici√≥n compleja

### Ejemplo B√°sico
```liva
main() {
    // Lanzar la operaci√≥n, obtener handle
    let handle = task async fetchUser(1)
    
    // Hacer MUCHAS otras cosas
    processData()
    doCalculations()
    prepareResponse()
    
    // Esperar manualmente cuando lo necesites
    let user = await handle
    print($"User: {user}")
}
```

### Lanzar M√∫ltiples Tasks
```liva
main() {
    // Lanzar 3 tasks en paralelo
    let t1 = task async fetchUser(1)
    let t2 = task async fetchUser(2)
    let t3 = task async fetchUser(3)
    
    // Hacer otras cosas mientras TODAS se ejecutan
    prepareUI()
    
    // Esperar todas
    let u1 = await t1
    let u2 = await t2
    let u3 = await t3
    
    print($"Users: {u1.name}, {u2.name}, {u3.name}")
}
```

### C√≥digo Rust Generado
```rust
let mut handle = liva_rt::spawn_async(async move { 
    fetch_user(1) 
});

// ... hacer otras cosas ...

let mut user = handle.await;
```

### ‚úÖ Cu√°ndo Usar
- Necesitas control preciso del timing
- Quieres lanzar m√∫ltiples operaciones y esperar despu√©s
- Composici√≥n compleja de async operations
- Patrones avanzados de concurrencia

### ‚ùå Cu√°ndo NO Usar
- Cuando la sintaxis simple `async` es suficiente
- Cuando quieres error binding autom√°tico
- Para fire-and-forget (usa `fire async`)

---

## 5. üü† Task Par (Control Manual Paralelo)

### Sintaxis
```liva
let handle = task par functionName(args)
let result = await handle
```

### Comportamiento
- Retorna un **JoinHandle** de thread
- **NO bloquea** autom√°ticamente
- Control manual de sincronizaci√≥n
- NO tiene error binding autom√°tico
- √ötil para fork-join patterns

### Ejemplo B√°sico
```liva
main() {
    // Lanzar computaci√≥n en thread separado
    let handle = task par heavyComputation(1000)
    
    // Procesar otros datos mientras computa
    let localData = processLocalData()
    
    // Esperar resultado cuando lo necesites
    let result = await handle
    
    // Combinar resultados
    let final = combineResults(localData, result)
}
```

### Fork-Join Pattern
```liva
main() {
    // Fork: Lanzar m√∫ltiples computaciones
    let t1 = task par compute(100)
    let t2 = task par compute(200)
    let t3 = task par compute(300)
    
    // Hacer trabajo local
    let local = processLocal()
    
    // Join: Esperar y combinar
    let r1 = await t1
    let r2 = await t2
    let r3 = await t3
    
    let total = r1 + r2 + r3 + local
}
```

### C√≥digo Rust Generado
```rust
let mut handle = liva_rt::spawn_parallel(move || { 
    heavy_computation(1000) 
});

// ... hacer otras cosas ...

let mut result = handle.await;
```

### ‚úÖ Cu√°ndo Usar
- Fork-join patterns
- Necesitas control preciso de threads
- M√∫ltiples computaciones paralelas con sincronizaci√≥n manual
- Patrones avanzados de paralelismo

### ‚ùå Cu√°ndo NO Usar
- Cuando la sintaxis simple `par` es suficiente
- Operaciones de I/O (usa `task async`)
- Para fire-and-forget (usa `fire par`)

---

## 6. üî¥ Fire Async (Fire-and-Forget Async)

### Sintaxis
```liva
fire async functionName(args)
```

### Comportamiento
- **NO retorna nada** (void)
- **NO bloquea** nunca
- Ejecuta en background
- **NO tiene error binding** (errores se pierden)
- Para operaciones no cr√≠ticas

### Ejemplo B√°sico
```liva
main() {
    // Ejecuta en background, contin√∫a inmediatamente
    fire async logEvent("User logged in")
    fire async sendEmail(user, "Welcome!")
    
    // Estas l√≠neas se ejecutan INMEDIATAMENTE
    // No espera a que log o email terminen
    print("Continuing...")
}
```

### Casos de Uso T√≠picos
```liva
// Logging no cr√≠tico
fire async logEvent($"Action performed at {timestamp}")

// Analytics
fire async trackEvent("button_clicked", metadata)

// Notificaciones que pueden fallar
fire async sendPushNotification(user, "New message")

// Sincronizaci√≥n en background
fire async syncToCloud(localData)

// Webhooks
fire async callWebhook(url, payload)
```

### C√≥digo Rust Generado
```rust
liva_rt::fire_async(async move { 
    log_event("User logged in".to_string()); 
});

liva_rt::fire_async(async move { 
    send_email(user, "Welcome!".to_string()); 
});
```

### ‚úÖ Cu√°ndo Usar
- Logging no cr√≠tico
- Analytics/telemetry
- Notificaciones que pueden fallar
- Operaciones donde NO te importa si fallan
- Background sync no cr√≠tico

### ‚ùå Cu√°ndo NO Usar
- Operaciones cr√≠ticas que DEBEN tener √©xito
- Cuando necesitas saber si hubo error
- Cuando necesitas el resultado
- Operaciones que requieren sincronizaci√≥n

---

## 7. üü£ Fire Par (Fire-and-Forget Parallel)

### Sintaxis
```liva
fire par functionName(args)
```

### Comportamiento
- **NO retorna nada** (void)
- **NO bloquea** nunca
- Ejecuta en thread separado
- **NO tiene error binding** (errores se pierden)
- Para procesamiento en background no cr√≠tico

### Ejemplo B√°sico
```liva
main() {
    // Lanza en thread separado, contin√∫a inmediatamente
    fire par cleanupTempFiles()
    fire par updateStatistics()
    
    // Estas l√≠neas se ejecutan INMEDIATAMENTE
    print("Cleanup started in background")
}
```

### Casos de Uso T√≠picos
```liva
// Cleanup no cr√≠tico
fire par cleanupOldLogs()
fire par deleteTempFiles()

// Procesamiento en background
fire par generateThumbnails(images)
fire par rebuildSearchIndex()

// Tareas de mantenimiento
fire par compactDatabase()
fire par optimizeCache()

// Procesamiento no cr√≠tico
fire par processLowPriorityQueue()
```

### C√≥digo Rust Generado
```rust
liva_rt::fire_parallel(move || { 
    cleanup_temp_files(); 
});

liva_rt::fire_parallel(move || { 
    update_statistics(); 
});
```

### ‚úÖ Cu√°ndo Usar
- Cleanup/mantenimiento no cr√≠tico
- Procesamiento en background de baja prioridad
- Tareas que pueden fallar sin consecuencias
- Operaciones que NO requieren sincronizaci√≥n

### ‚ùå Cu√°ndo NO Usar
- Operaciones cr√≠ticas
- Cuando necesitas saber el resultado
- Computaci√≥n donde los errores son importantes
- Operaciones que requieren coordinaci√≥n

---

## üéì Gu√≠a de Decisi√≥n

### Diagrama de Flujo

```
¬øTe importa el resultado?
‚îÇ
‚îú‚îÄ NO ‚îÄ‚Üí ¬øAsync o CPU?
‚îÇ        ‚îú‚îÄ Async (I/O) ‚îÄ‚Üí fire async f()
‚îÇ        ‚îî‚îÄ CPU          ‚îÄ‚Üí fire par f()
‚îÇ
‚îî‚îÄ S√ç ‚îÄ‚Üí ¬øNecesitas control manual?
         ‚îÇ
         ‚îú‚îÄ S√ç ‚îÄ‚Üí ¬øAsync o CPU?
         ‚îÇ        ‚îú‚îÄ Async (I/O) ‚îÄ‚Üí task async f()
         ‚îÇ        ‚îî‚îÄ CPU          ‚îÄ‚Üí task par f()
         ‚îÇ
         ‚îî‚îÄ NO ‚îÄ‚Üí ¬øQuieres lazy evaluation?
                  ‚îÇ
                  ‚îú‚îÄ S√ç ‚îÄ‚Üí ¬øAsync o CPU?
                  ‚îÇ        ‚îú‚îÄ Async (I/O) ‚îÄ‚Üí async f()
                  ‚îÇ        ‚îî‚îÄ CPU          ‚îÄ‚Üí par f()
                  ‚îÇ
                  ‚îî‚îÄ NO ‚îÄ‚Üí f() (normal s√≠ncrono)
```

### Tabla de Decisi√≥n R√°pida

| Necesito... | Usa esto |
|-------------|----------|
| Resultado inmediato | `f()` |
| I/O con lazy await | `async f()` |
| CPU con lazy join | `par f()` |
| Control manual async | `task async f()` |
| Control manual parallel | `task par f()` |
| Fire-and-forget I/O | `fire async f()` |
| Fire-and-forget CPU | `fire par f()` |
| Error handling | Cualquiera excepto `fire` |

## üîÑ Conversi√≥n entre Modos

### De Normal a Async/Par
```liva
// Normal - bloquea
let user = fetchUser(1)

// Async - lazy await
let user = async fetchUser(1)

// Par - lazy join
let result = par compute(100)
```

### De Lazy a Task
```liva
// Lazy - await autom√°tico
let user = async fetchUser(1)
print(user.name)  // Await aqu√≠

// Task - await manual
let handle = task async fetchUser(1)
// ... hacer cosas ...
let user = await handle
```

### De Task a Fire
```liva
// Task - obtienes handle
let handle = task async logEvent("test")

// Fire - no obtienes nada
fire async logEvent("test")
```

## üí° Patrones Comunes

### Patr√≥n 1: M√∫ltiples Tasks + Lazy
```liva
// Lanzar tasks con control manual
let t1 = task async fetchUser(1)
let t2 = task async fetchUser(2)

// Lazy evaluation para computaci√≥n local
let localResult = par processLocal()

// Fire para logging
fire async logEvent("Processing started")

// Await manual de tasks
let u1 = await t1
let u2 = await t2

// Lazy join autom√°tico
print(localResult)
```

### Patr√≥n 2: Error Handling Mixto
```liva
// Critical: con error binding
let user, err = async fetchUser(id)
if err != "" {
    logError(err)
    return
}

// Non-critical: fire and forget
fire async sendWelcomeEmail(user)
```

### Patr√≥n 3: Fork-Join con Lazy
```liva
// Fork: Lanzar m√∫ltiples computaciones
let t1 = task par compute(100)
let t2 = task par compute(200)

// Lazy evaluation mientras tasks corren
let extra = par quickCompute(10)

// Join tasks
let r1 = await t1
let r2 = await t2

// Lazy join autom√°tico
let total = r1 + r2 + extra
```

## üìö Referencias

- [CONCURRENCIA_SISTEMA.md](CONCURRENCIA_SISTEMA.md) - Especificaci√≥n t√©cnica completa
- [ERROR_HANDLING.md](ERROR_HANDLING.md) - Error handling detallado
- [PLAN_CONCURRENCIA.md](PLAN_CONCURRENCIA.md) - Roadmap de implementaci√≥n

---

**√öltima actualizaci√≥n:** 18 de octubre de 2025
